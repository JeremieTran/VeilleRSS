"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const directory_reader_async_1 = __importDefault(require("./directory-reader-async"));
const directory_reader_sync_1 = __importDefault(require("./directory-reader-sync"));
const VALID_IMPORT_EXTENSIONS = new Set(['.js', '.mjs', '.ts', '.json']);
const handlers = { async: asyncHandler, sync: syncHandler };
/**
 * Synchronously import modules from the specified directory.
 * @param {ImportedModulesPrivateOptions} options - The private options generated by the preparePrivateOptions function.
 * @returns {ImportedModules} An object containing all imported modules.
 */
function syncHandler(options) {
    const modules = {};
    const filesPaths = (0, directory_reader_sync_1.default)(options, options.targetDirectoryPath);
    let index = 0;
    for (const filePath of filesPaths) {
        const isModuleImported = importModule(filePath, index, options, modules);
        if (isModuleImported)
            index += 1;
        if (index === options.limit)
            break;
    }
    return modules;
}
/**
 * Asynchronously import modules from the specified directory.
 * @param {ImportedModulesPrivateOptions} options - The private options generated by the preparePrivateOptions function.
 * @returns {Promise<ImportedModules>} An object containing all imported modules.
 */
async function asyncHandler(options) {
    const modules = {};
    const filesPaths = await (0, directory_reader_async_1.default)(options, options.targetDirectoryPath);
    let index = 0;
    for (const filePath of filesPaths) {
        const isModuleImported = importModule(filePath, index, options, modules);
        if (isModuleImported)
            index += 1;
        if (index === options.limit)
            break;
    }
    return modules;
}
/**
 * Import a module and add it to the modules object.
 * @param {string} filePath - The path to the file to import.
 * @param {number} index - The index of the module.
 * @param {ImportedModulesPrivateOptions} options - The private options generated by the preparePrivateOptions function.
 * @param {ImportedModules} modules - The object containing all imported modules.
 * @returns {boolean} Whether the module was imported or not.
 */
function importModule(filePath, index, options, modules) {
    const { name: fileName, ext: fileExtension } = node_path_1.default.parse(filePath);
    const isValidModuleExtension = VALID_IMPORT_EXTENSIONS.has(fileExtension);
    const isDeclarationFile = filePath.endsWith('.d.ts');
    const isValidFilePath = options.importPattern ? options.importPattern.test(filePath) : true;
    if (!isValidModuleExtension)
        return false;
    if (!isValidFilePath)
        return false;
    if (isDeclarationFile)
        return false;
    const relativeModulePath = filePath.slice(options.targetDirectoryPath.length + 1);
    // eslint-disable-next-line security/detect-non-literal-require, @typescript-eslint/no-var-requires, unicorn/prefer-module
    const importedModule = require(filePath);
    modules[relativeModulePath] = importedModule;
    if (options.callback) {
        options.callback(fileName, relativeModulePath, importedModule, index);
    }
    return true;
}
/**
 * Import all modules from the specified directory synchronously or asynchronously.
 * @param {ImportedModulesPrivateOptions} options - The private options generated by the preparePrivateOptions function.
 * @returns {ImportedModules | Promise<ImportedModules>} An object containing all imported modules.
 */
function importModules(options) {
    if (!handlers[options.importMode]) {
        throw new Error(`Expected sync or async import method, but got: ${options.importMode}`);
    }
    return handlers[options.importMode](options);
}
exports.default = importModules;
